{\rtf1\ansi\ansicpg1252\cocoartf2822
\cocoatextscaling0\cocoaplatform0{\fonttbl\f0\fswiss\fcharset0 Helvetica;}
{\colortbl;\red255\green255\blue255;}
{\*\expandedcolortbl;;}
\margl1440\margr1440\vieww11520\viewh8400\viewkind0
\pard\tx720\tx1440\tx2160\tx2880\tx3600\tx4320\tx5040\tx5760\tx6480\tx7200\tx7920\tx8640\pardirnatural\partightenfactor0

\f0\fs24 \cf0 # --- Test: program Instruction Memory via buses and run a small program ---\
# Program:\
#   0/1 : LDI R1,#5   (HI=9,  LO=5)\
#   2/3 : LDI R2,#3   (HI=10, LO=3)\
#   4/5 : ADD R2,R1   (HI=2,  LO=4)  ; ALU_out should be 8 during execute\
#   6/7 : SUB R2,R1   (HI=2,  LO=5)  ; ALU_out should be 3 during execute\
\
clk state PC_inc IP InstructionMemory_dataInput InstructionMemory_ctrl IR-HI-Write IR-LO-Write IR_HI[3:2] IR_HI[1:0] IR_LO[3:2] IR_LO[1:0] ALU_out\
\
# =========================================================\
# 1. PROGRAM INSTRUCTION MEMORY USING NORMAL INTERFACE\
# ---------------------------------------------------------\
# We rely on your control unit / PC_inc to step through IF1/IF2,\
# and we just provide the data nibble and InstructionMemory_ctrl\
# to store HI/LO nibbles at successive addresses.\
#\
# Addresses and nibbles:\
#   addr 0 : 0x9  (HI of LDI R1,#5)\
#   addr 1 : 0x5  (LO of LDI R1,#5)\
#   addr 2 : 0xA  (HI of LDI R2,#3)\
#   addr 3 : 0x3  (LO of LDI R2,#3)\
#   addr 4 : 0x2  (HI of ADD R2,R1)\
#   addr 5 : 0x4  (LO of ADD R2,R1)\
#   addr 6 : 0x2  (HI of SUB R2,R1)\
#   addr 7 : 0x5  (LO of SUB R2,R1)\
# =========================================================\
\
# Spin FSM / PC into a stable starting state (as you were doing before)\
repeat(39) C X X X 0 0 X X X X X X X\
\
# --- FIRST instruction: LDI R1,#5 ---\
# addr 0 <- 0x9  (HI of LDI R1,#5)\
C X X X 9 1 X X  X X X X X\
# addr 1 <- 0x5  (LO of LDI R1,#5)\
C X X X 5 1 X X  X X X X X\
# next three cycles: decode, execute, writeback \'96 ALU_out don't-care\
repeat(3) C X X X 0 0 X X X X X X X\
\
# --- SECOND instruction: LDI R2,#3 ---\
# addr 2 <- 0xA  (HI of LDI R2,#3)\
C X X X 10 1 X X  X X X X X\
# addr 3 <- 0x3  (LO of LDI R2,#3)\
C X X X 3  1 X X  X X X X X\
# next three cycles: decode, execute, writeback \'96 ALU_out don't-care\
repeat(3) C X X X 0 0 X X X X X X X\
\
# --- THIRD instruction: ADD R2,R1 ---\
# addr 4 <- 0x2  (HI of ADD R2,R1)\
C X X X 2 1 X X  X X X X X\
# addr 5 <- 0x4  (LO of ADD R2,R1)\
C X X X 4 1 X X  X X X X X\
# next three cycles: decode, execute, writeback\
# During the EXECUTE cycle of this ADD, ALU_out[3:0] should be 8 (0x8).\
# Once you know which 'state' bit = Execute, you can change the Xs\
# on the correct cycle to (8) instead of X.\
repeat(3) C X X X 0 0 X X X X X X X\
\
# --- FOURTH instruction: SUB R2,R1 ---\
# addr 6 <- 0x2  (HI of SUB R2,R1)\
C X X X 2 1 X X  X X X X X\
# addr 7 <- 0x5  (LO of SUB R2,R1)\
C X X X 5 1 X X  X X X X X\
# next three cycles: decode, execute, writeback\
# During the EXECUTE cycle of this SUB, ALU_out[3:0] should be 3 (0x3).\
# Again, once you align this with 'state', you can set ALU_out to 3\
# on the right cycle.\
repeat(3) C X X X 0 0 X X X X X X X\
\
# =========================================================\
# 2. RUN / OBSERVE PHASE (OPTIONAL)\
# ---------------------------------------------------------\
# At this point, the program is in instruction memory and the CPU\
# has already stepped through the IF/ID/EX/WB cycles used during\
# programming. If you simply keep clocking, you can watch:\
#   - R1 being loaded with 5\
#   - R2 being loaded with 3\
#   - ADD R2,R1 being executed (ALU_out = 8)\
#   - SUB R2,R1 being executed (ALU_out = 3)\
#\
# Because the exact timing of your FSM may differ, we keep ALU_out\
# as don't-care here. Once you know *which* cycle is the execute\
# stage for ADD and SUB, you can replace the 'X' in ALU_out with\
# 8 and 3 at the appropriate lines.\
# ==========================================================\
\
# Example: just keep clocking to let the CPU run\
repeat(20) C X X X 0 2 X X X X X X X}